# JVM 堆内存

Java 堆内存主要分为 新生代 老年代 和 永久代
1. 新生代
    * Eden区
    * S0
    * S1
2. 老年代
    新生代中经过一定次数的Minor GC（默认15次）后依然存活的对象，会被移动到老年代
3. 永久代
    包含类、方法等细节的元信息，jdk1.8以后叫元数据区

# Java 垃圾收集器
### Serial收集器
新生代垃圾收集器，串行，使用标记复制算法，在进行垃圾回收时会暂停其他所有的工作线程（stop the world，简称STW）直至回收结束。
使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收
### ParNew收集器
新生代垃圾收集器，Serial收集器的多线程版本，默认开启的收集线程数与CPU的数量相同，关注与缩短垃圾收集的时间。
使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。
### Parallel Scavenge 收集器
新生代垃圾收集器，使用标记复制算法，关注CPU吞吐量。
使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。
### Serial Old收集器
老年代收集器，单线程串行，使用标记整理算法（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲），减少内存碎片
### Parallel Old收集器
老年代收集器，多线程并行，使用标记整理算法（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）
### CMS（Concurrent Mark Sweep）收集器
老年代收集器，致力于获取最短回收停顿时间，多线程，使用并发标记清除算法，默认回收线程数：（处理器核心数量 + 3）/4。
> 并发和并行的区别：

> 并行（Parallel）：并行描述的多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程为等待状态。

> 并发（Concurrent）：并发描述的垃圾收集线程与用户线程之间的关系，说明同一时间垃圾收集线程与用户线程都在工作，由于用户线程并未冻结，因此还能继续相应服务请求，但由于垃圾收集器线程占用了一定的系统资源，此时应用程序处理的吞吐量将受到一定影响。

设计目标/优点：
避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：

1. 不对老年代进行整理，而是使用空闲列表（free-list）来管理内存空间的回收
2. 在mark-and-sweep（标记-清除）阶段的大部分工作和应用线程一起并发执行。

**工作流程：**
1. 初始化标记(CMS-initial-mark) ,标记root，会导致stw；
2. 并发标记(CMS-concurrent-mark)，与用户线程同时运行；
3. 预清理（CMS-concurrent-preclean），与用户线程同时运行；
4. 重新标记(CMS-remark) ，会导致stw；
5. 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；
6. 调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；
7. 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；


### G1收集器
概述：

1. G1的设计原则是"首先收集尽可能多的垃圾(Garbage First)"。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；
2. G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；
3. G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；
4. G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。